{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started Full code on github . Install pip install sanic_camelcase_middelware Dependencies pyhumps sanic Example from sanic import Sanic from sanic_camelcase_middleware import Camelize app = Sanic(__name__) Camelize(app)","title":"Getting Started"},{"location":"#getting-started","text":"Full code on github .","title":"Getting Started"},{"location":"#install","text":"pip install sanic_camelcase_middelware","title":"Install"},{"location":"#dependencies","text":"pyhumps sanic","title":"Dependencies"},{"location":"#example","text":"from sanic import Sanic from sanic_camelcase_middleware import Camelize app = Sanic(__name__) Camelize(app)","title":"Example"},{"location":"_sidebar/","text":"Getting started Introduction GOS & BUP GOS BUP Quick start Language Specification Introduction Blocks Data types Identifiers Comments Expressions Data access Lists Constraints Strings Glossary Result","title":" sidebar"},{"location":"access/","text":"Data access Accesses can be used to retrieve a value (in parameters or in variables when they already have a value, i.e. in the output section), or to impose constraints on variables . Identifier access <ident> Array index access < <ident> | <entityAttrAccess> | <arrayIndexAccess> > [<int_expr>] Matrix row access BUP allows generating a list by accessing a row of a matrix using the operator _ , for example varsX[_][1] . < <ident> | <entityAttrAccess> | <arrayIndexAccess> > [_] <[<int_expr>]>* Entity attribute access < <ident> | <entityAttrAccess> | <arrayIndexAccess> >.<ident>","title":"Data access"},{"location":"access/#data-access","text":"Accesses can be used to retrieve a value (in parameters or in variables when they already have a value, i.e. in the output section), or to impose constraints on variables .","title":"Data access"},{"location":"access/#identifier-access","text":"<ident>","title":"Identifier access"},{"location":"access/#array-index-access","text":"< <ident> | <entityAttrAccess> | <arrayIndexAccess> > [<int_expr>]","title":"Array index access"},{"location":"access/#matrix-row-access","text":"BUP allows generating a list by accessing a row of a matrix using the operator _ , for example varsX[_][1] . < <ident> | <entityAttrAccess> | <arrayIndexAccess> > [_] <[<int_expr>]>*","title":"Matrix row access"},{"location":"access/#entity-attribute-access","text":"< <ident> | <entityAttrAccess> | <arrayIndexAccess> >.<ident>","title":"Entity attribute access"},{"location":"bup/","text":"BUP program structure The model file structure is divided in four blocks: - Entity definition block , where entities are defined. - Viewpoint block , where variables and parameters are declared. - Constraints block , where constraints are defined. - Output block , where custom output is defined. <entityDefinitionBlock>? <viewpointBlock> <constraintsBlock> <outputBlock>? Entity Definition block This block is used to define the new entities (a kind of tuples) to be used at the viewpoint. <<entityDefinition>;>* Viewpoint block This block is used to define the variables and parameters used to model the problem. viewpoint : << <variableDeclaration> | <parameterDeclaration> | <entityDeclaration> | <arrayDeclaration> >;>* Variable declaration var bool? <ident> Param declaration param <int | bool> <ident> Entity declaration <entity_ident> <ident> Array declaration Array indexes range from 0 to n -1, where n is the array size. < <varDeclaration> | <paramDeclaration> | <entityDeclaration> > <[<int_expr>]>* Constraints block constraints: <<constraint>;>* Output block output: <<string>;>*","title":"BUP program structure"},{"location":"bup/#bup-program-structure","text":"The model file structure is divided in four blocks: - Entity definition block , where entities are defined. - Viewpoint block , where variables and parameters are declared. - Constraints block , where constraints are defined. - Output block , where custom output is defined. <entityDefinitionBlock>? <viewpointBlock> <constraintsBlock> <outputBlock>?","title":"BUP program structure"},{"location":"bup/#entity-definition-block","text":"This block is used to define the new entities (a kind of tuples) to be used at the viewpoint. <<entityDefinition>;>*","title":"Entity Definition block"},{"location":"bup/#viewpoint-block","text":"This block is used to define the variables and parameters used to model the problem. viewpoint : << <variableDeclaration> | <parameterDeclaration> | <entityDeclaration> | <arrayDeclaration> >;>*","title":"Viewpoint block"},{"location":"bup/#variable-declaration","text":"var bool? <ident>","title":"Variable declaration"},{"location":"bup/#param-declaration","text":"param <int | bool> <ident>","title":"Param declaration"},{"location":"bup/#entity-declaration","text":"<entity_ident> <ident>","title":"Entity declaration"},{"location":"bup/#array-declaration","text":"Array indexes range from 0 to n -1, where n is the array size. < <varDeclaration> | <paramDeclaration> | <entityDeclaration> > <[<int_expr>]>*","title":"Array declaration"},{"location":"bup/#constraints-block","text":"constraints: <<constraint>;>*","title":"Constraints block"},{"location":"bup/#output-block","text":"output: <<string>;>*","title":"Output block"},{"location":"bup_intro/","text":"Language specification This chapter contains the specification of the BUP modelling language, the language of GOS tool. BUP is a SAT-oriented declarative CSP modelling programming language. Similarly as we do with imperative languages, we want models written in BUP language to be as much reusable as possible, i.e., we want to separate the problem definition from the data of a particular instance. For this reason we deal with CSPs using two distinct files: - The model file (written in BUP ), which describes the semantics of the problem at hand by means of defining the needed variables, parameters and constraints. - The parameters file (written in JSON ), which describes the values of the parameters of the particular instance we want to solve.","title":"Language specification"},{"location":"bup_intro/#language-specification","text":"This chapter contains the specification of the BUP modelling language, the language of GOS tool. BUP is a SAT-oriented declarative CSP modelling programming language. Similarly as we do with imperative languages, we want models written in BUP language to be as much reusable as possible, i.e., we want to separate the problem definition from the data of a particular instance. For this reason we deal with CSPs using two distinct files: - The model file (written in BUP ), which describes the semantics of the problem at hand by means of defining the needed variables, parameters and constraints. - The parameters file (written in JSON ), which describes the values of the parameters of the particular instance we want to solve.","title":"Language specification"},{"location":"bup_result/","text":"BUP BUP is a new declarative programming language for modelling CSP and solve them using SAT . As far as we know, there are no precedents of declarative modelling languages allowing to define tuples. BUP permits create complex data structures (called entities) that allow you to group params and variables in a common framework. In next iterations of the language it is possible to consider the idea of extending the use of tuples to object orientation, allowing for instance to include constraints over objects in the definition of the entities. To sum up, BUP is a language that has emerged to improve expressiveness when encoding any CSP to SAT by allowing: - Define int or bool parameters - Use forall structures to loop over parameters. - Use if structures for conditionally apply constraints. - Generate clause lists by using comprehension lists . - Translate any formula to CNF automatically. - Customize the output when the model is satisfable. - Produce a clear CNF encoding resulting of the individual conjunction of CNFs resulting from translating each particular constraint. - Be easily extendible to support further constraints implemented in the SMT API.","title":"BUP"},{"location":"bup_result/#bup","text":"BUP is a new declarative programming language for modelling CSP and solve them using SAT . As far as we know, there are no precedents of declarative modelling languages allowing to define tuples. BUP permits create complex data structures (called entities) that allow you to group params and variables in a common framework. In next iterations of the language it is possible to consider the idea of extending the use of tuples to object orientation, allowing for instance to include constraints over objects in the definition of the entities. To sum up, BUP is a language that has emerged to improve expressiveness when encoding any CSP to SAT by allowing: - Define int or bool parameters - Use forall structures to loop over parameters. - Use if structures for conditionally apply constraints. - Generate clause lists by using comprehension lists . - Translate any formula to CNF automatically. - Customize the output when the model is satisfable. - Produce a clear CNF encoding resulting of the individual conjunction of CNFs resulting from translating each particular constraint. - Be easily extendible to support further constraints implemented in the SMT API.","title":"BUP"},{"location":"comments/","text":"Comments Code could be commented using the following two methods: // to comment one line. /* . . . */ to comment multiple lines.","title":"Comments"},{"location":"comments/#comments","text":"Code could be commented using the following two methods: // to comment one line. /* . . . */ to comment multiple lines.","title":"Comments"},{"location":"constraints/","text":"A constraint in GOS can be (and only be) a: - Propositional Formula - Cardinality Constraint - forall structure - if structure Propositional Formula Although the GOS compiler can recognize syntactically any propositional formula, the BUP language only permits those formulas with trivial translation to CNF , more precisely, formulas that can be translated to a linear number of clauses without adding auxiliary variables. This decision was taken for the first version of BUP, but since GOS's parser already supports any kind of propositional formula, it would be easy to support any propositional formula in future versions if desired. This decision was taken mainly for the sake of a clear correspondence with the BUP file and the generated SAT formulas. Also, good reformulations of more complex formulas involve challenges such as detection of common sub-expressions, which are out of the scope of the first stage of the project. Example of allowed and not allowed propositional formulas For instance, given the following propositional formula: a & b & c | d & e A translation to CNF without intro ducing auxiliary variables would be: (a | d) & (a | e) & (b | d) & (b | e) & (c | d) & (c | e) It generates a quadratic number of new clauses. **This propositional formula is not semantically allowed by GOS**. Given this other formula: a & b & c | d The translation to CNF would be (a | d) & (b | d) & (c | d) It generates a linear number of clauses. **This propositional formula is allowed by GOS**. Therefore, the GOS compiler does a semantic checks to ensure that the formulas contained in a BUP file fulil certain properties. The semantic rules that GOS applies over Boolean operations are described in the following subsections. The following figure shows how different operands could be treated in GOS when constructing Boolean Formulas: LITERAL is a VARIABLE or its negation AND_LITERALS is an and operation between literals. A LITERAL is a particular case of AND_LITERALS where there is only one literal. OR_LITERALS is an or operation between literals. A LITERAL is a particular case of OR_LITERALS where there is only one literal. AND_CLAUSES is an and operations between clauses. OR_LITERALS is a particular case of AND_CLAUSES where there is only one clause. AND_LITERAL is a particular case of AND_CLAUSES where all the clauses are unitary. These are the GOS operators and their precedence: Name Operator Associativity Precedence Negation ! - 1 And & Left 2 Or | Left 3 Implication -> Left 4 Double Implication <-> Left 5 Variable Acces to a declared variable x Negation !x The negation operator has the following truth table: a !a 0 1 1 0 The allowed operations using ! operator are: Result Expression LITERAL !LITERAL OR_LITERALS !AND_LITERALS AND_LITERALS !OR_LITERALS And a & b The and operator & has the following truth table: a b a & b 0 0 0 0 1 0 1 0 0 1 1 1 The And operation could also be constructed through a list using the operator && and a list of clauses. As it is a unary operator, && has the precedence in the same level as the negation operator (see operator precedence) &&( <list> ) The allowed operations using & operator are: Result Expression OR_LITERALS & OR_LITERALS AND_CLAUSES OR_LITERALS & AND_LITERALS AND_CLAUSES AND_LITERALS & OR_LITERALS AND_CLAUSES AND_LITERALS & AND_LITERALS AND_LITERALS AND_CLAUSES & AND_CLAUSES AND_CLAUSES AND_LITERALS & OR_LITERALS AND_CLAUSES AND_CLAUSES & AND_CLAUSES AND_CLAUSES Or a | b The Or operator | has the following truth table: a b a | b 0 0 0 0 1 1 1 0 1 1 1 1 The Or operation could also be constructed through a list using the operator || and a list of clauses. As it is a unary operator, || has the precedence in the same level as the negation operator (see operator precedence) ||( <list> ) The allowed operations using & operator are: Result Expression LITERAL | LITERAL OR_LITERALS OR_LITERALS | OR_LITERALS OR_LITERALS OR_LITERALS | AND_LITERALS AND_CLAUSES Implication a -> b The implication operator has the following truth table: a b a -> b 0 0 1 0 1 1 1 0 0 1 1 1 The allowed operations using -> operator are: Result Expression AND_LITERALS -> OR_LITERALS OR_LITERALS OR_LITERALS <- AND_LITERALS OR_LITERALS LITERAL -> AND_LITERALS AND_CLAUSES AND_LITERALS <- LITERAL AND_CLAUSES Double Implication a <-> b The double implication operator has the following truth table: a b a <-> b 0 0 1 0 1 0 1 0 0 1 1 1 The allowed operations using <-> operator are: Result Expression LITERAL <-> AND_LITERALS AND_CLAUSES AND_LITERALS <-> LITERAL AND_CLAUSES LITERAL <-> OR_LITERALS AND_CLAUSES OR_LITERALS <-> LITERAL AND_CLAUSES Cardinality Constraints Apart from simple boolean formulas, BUP allows Cardinality Constraints in the model specification, that are later automatically translated to CNF by GOS . These kind of constraints state that at most (at least, or exactly) k out of a propositional literals list can be true. Exactly One: EO( <list> ) At Most One: AMO ( <list> ) At Least One: ALO ( <list> ) Exactly k : EK( <list> ) At Most k : AMK ( <list> ) At Least k : ALK ( <list> ) forall Structure BUP language support forall structures used to loop lists and add constraints to the model. forall ( <ident> in <list> <, <ident> in <list> >*) { <constraint>* }; if Structure BUP supports if structures used to conditionally add constraints to the model. <if ( <boolExpression> ) { <constraint>* } > <else if ( <boolExpression> ) { <constraint>* } >* <else { <constraint>* } >?","title":"Constraints"},{"location":"constraints/#propositional-formula","text":"Although the GOS compiler can recognize syntactically any propositional formula, the BUP language only permits those formulas with trivial translation to CNF , more precisely, formulas that can be translated to a linear number of clauses without adding auxiliary variables. This decision was taken for the first version of BUP, but since GOS's parser already supports any kind of propositional formula, it would be easy to support any propositional formula in future versions if desired. This decision was taken mainly for the sake of a clear correspondence with the BUP file and the generated SAT formulas. Also, good reformulations of more complex formulas involve challenges such as detection of common sub-expressions, which are out of the scope of the first stage of the project. Example of allowed and not allowed propositional formulas For instance, given the following propositional formula: a & b & c | d & e A translation to CNF without intro ducing auxiliary variables would be: (a | d) & (a | e) & (b | d) & (b | e) & (c | d) & (c | e) It generates a quadratic number of new clauses. **This propositional formula is not semantically allowed by GOS**. Given this other formula: a & b & c | d The translation to CNF would be (a | d) & (b | d) & (c | d) It generates a linear number of clauses. **This propositional formula is allowed by GOS**. Therefore, the GOS compiler does a semantic checks to ensure that the formulas contained in a BUP file fulil certain properties. The semantic rules that GOS applies over Boolean operations are described in the following subsections. The following figure shows how different operands could be treated in GOS when constructing Boolean Formulas: LITERAL is a VARIABLE or its negation AND_LITERALS is an and operation between literals. A LITERAL is a particular case of AND_LITERALS where there is only one literal. OR_LITERALS is an or operation between literals. A LITERAL is a particular case of OR_LITERALS where there is only one literal. AND_CLAUSES is an and operations between clauses. OR_LITERALS is a particular case of AND_CLAUSES where there is only one clause. AND_LITERAL is a particular case of AND_CLAUSES where all the clauses are unitary. These are the GOS operators and their precedence: Name Operator Associativity Precedence Negation ! - 1 And & Left 2 Or | Left 3 Implication -> Left 4 Double Implication <-> Left 5","title":"Propositional Formula"},{"location":"constraints/#variable","text":"Acces to a declared variable x","title":"Variable"},{"location":"constraints/#negation","text":"!x The negation operator has the following truth table: a !a 0 1 1 0 The allowed operations using ! operator are: Result Expression LITERAL !LITERAL OR_LITERALS !AND_LITERALS AND_LITERALS !OR_LITERALS","title":"Negation"},{"location":"constraints/#and","text":"a & b The and operator & has the following truth table: a b a & b 0 0 0 0 1 0 1 0 0 1 1 1 The And operation could also be constructed through a list using the operator && and a list of clauses. As it is a unary operator, && has the precedence in the same level as the negation operator (see operator precedence) &&( <list> ) The allowed operations using & operator are: Result Expression OR_LITERALS & OR_LITERALS AND_CLAUSES OR_LITERALS & AND_LITERALS AND_CLAUSES AND_LITERALS & OR_LITERALS AND_CLAUSES AND_LITERALS & AND_LITERALS AND_LITERALS AND_CLAUSES & AND_CLAUSES AND_CLAUSES AND_LITERALS & OR_LITERALS AND_CLAUSES AND_CLAUSES & AND_CLAUSES AND_CLAUSES","title":"And"},{"location":"constraints/#or","text":"a | b The Or operator | has the following truth table: a b a | b 0 0 0 0 1 1 1 0 1 1 1 1 The Or operation could also be constructed through a list using the operator || and a list of clauses. As it is a unary operator, || has the precedence in the same level as the negation operator (see operator precedence) ||( <list> ) The allowed operations using & operator are: Result Expression LITERAL | LITERAL OR_LITERALS OR_LITERALS | OR_LITERALS OR_LITERALS OR_LITERALS | AND_LITERALS AND_CLAUSES","title":"Or"},{"location":"constraints/#implication","text":"a -> b The implication operator has the following truth table: a b a -> b 0 0 1 0 1 1 1 0 0 1 1 1 The allowed operations using -> operator are: Result Expression AND_LITERALS -> OR_LITERALS OR_LITERALS OR_LITERALS <- AND_LITERALS OR_LITERALS LITERAL -> AND_LITERALS AND_CLAUSES AND_LITERALS <- LITERAL AND_CLAUSES","title":"Implication"},{"location":"constraints/#double-implication","text":"a <-> b The double implication operator has the following truth table: a b a <-> b 0 0 1 0 1 0 1 0 0 1 1 1 The allowed operations using <-> operator are: Result Expression LITERAL <-> AND_LITERALS AND_CLAUSES AND_LITERALS <-> LITERAL AND_CLAUSES LITERAL <-> OR_LITERALS AND_CLAUSES OR_LITERALS <-> LITERAL AND_CLAUSES","title":"Double Implication"},{"location":"constraints/#cardinality-constraints","text":"Apart from simple boolean formulas, BUP allows Cardinality Constraints in the model specification, that are later automatically translated to CNF by GOS . These kind of constraints state that at most (at least, or exactly) k out of a propositional literals list can be true. Exactly One: EO( <list> ) At Most One: AMO ( <list> ) At Least One: ALO ( <list> ) Exactly k : EK( <list> ) At Most k : AMK ( <list> ) At Least k : ALK ( <list> )","title":"Cardinality Constraints"},{"location":"constraints/#forall-structure","text":"BUP language support forall structures used to loop lists and add constraints to the model. forall ( <ident> in <list> <, <ident> in <list> >*) { <constraint>* };","title":"forall Structure"},{"location":"constraints/#if-structure","text":"BUP supports if structures used to conditionally add constraints to the model. <if ( <boolExpression> ) { <constraint>* } > <else if ( <boolExpression> ) { <constraint>* } >* <else { <constraint>* } >?","title":"if Structure"},{"location":"data/","text":"Data types BUP has two types of data, according to its nature: - Parameters : Instance related. Used to describe the instance specification. - Variables : Model related. We must differentiate this variables from the imperative languages variables. SAT variables are always boolean, but you cannot do arithmetic operations or assign them. Instead, you can define constraints over variables, expressed, for example, as propositional formulas. They are strictly designed for defining the SAT model and their value can only be retrieved in the output-block specification, where their value can be accessed similarly as is done with boolean parameters. Both, parameters and variables, could be declared individually or using data structures: multidimensional arrays or defined types (entities) . Basic types The basic types are those with which you can define parameters: int : Represents an integer value. bool : Represents a boolean. It can take values true or false. Defined types: Entities BUP allows defining new entities consisting of a tuple of data elements. These data elements can contain both parameters and variables. The only restriction is that entity types used in the definition of an element must have been declared previously. <identifier> { < <parameter declaration> | <variable declaration> | <entity declaration> | <array declaration> >+ } n-dimentional arrays It is allowed to define n -dimentional arrays of any basic type, variable or entity. The arrays index range from 0 to m -1, where m is the length of the indexed dimension of the array.","title":"Data types"},{"location":"data/#data-types","text":"BUP has two types of data, according to its nature: - Parameters : Instance related. Used to describe the instance specification. - Variables : Model related. We must differentiate this variables from the imperative languages variables. SAT variables are always boolean, but you cannot do arithmetic operations or assign them. Instead, you can define constraints over variables, expressed, for example, as propositional formulas. They are strictly designed for defining the SAT model and their value can only be retrieved in the output-block specification, where their value can be accessed similarly as is done with boolean parameters. Both, parameters and variables, could be declared individually or using data structures: multidimensional arrays or defined types (entities) .","title":"Data types"},{"location":"data/#basic-types","text":"The basic types are those with which you can define parameters: int : Represents an integer value. bool : Represents a boolean. It can take values true or false.","title":"Basic types"},{"location":"data/#defined-types-entities","text":"BUP allows defining new entities consisting of a tuple of data elements. These data elements can contain both parameters and variables. The only restriction is that entity types used in the definition of an element must have been declared previously. <identifier> { < <parameter declaration> | <variable declaration> | <entity declaration> | <array declaration> >+ }","title":"Defined types: Entities"},{"location":"data/#n-dimentional-arrays","text":"It is allowed to define n -dimentional arrays of any basic type, variable or entity. The arrays index range from 0 to m -1, where m is the length of the indexed dimension of the array.","title":"n-dimentional arrays"},{"location":"expr/","text":"Expressions Expressions are only permitted between parameters of basic types. An expression could be: A value of basic type . A data access . A list aggregation operation . An operation between one or more expressions . In the following table we can find all implemented operators with their associativity and types. They are sorted according to their priority: Operator Associativity Input type Output type not - bool bool / , % , * Left int int + , - Left int int < , <= , > , >= Left int bool == , != Left int or bool bool and , or Left bool bool if-then-else Right int or bool int or bool if-then-else structure <bool_expr> ? <expr1> : <expr2> If <bool_expr> evaluates true resolves <expr1> else <expr2> .","title":"Expressions"},{"location":"expr/#expressions","text":"Expressions are only permitted between parameters of basic types. An expression could be: A value of basic type . A data access . A list aggregation operation . An operation between one or more expressions . In the following table we can find all implemented operators with their associativity and types. They are sorted according to their priority: Operator Associativity Input type Output type not - bool bool / , % , * Left int int + , - Left int int < , <= , > , >= Left int bool == , != Left int or bool bool and , or Left bool bool if-then-else Right int or bool int or bool","title":"Expressions"},{"location":"expr/#if-then-else-structure","text":"<bool_expr> ? <expr1> : <expr2> If <bool_expr> evaluates true resolves <expr1> else <expr2> .","title":"if-then-else structure"},{"location":"glossary/","text":"","title":"Glossary"},{"location":"gos_result/","text":"GOS (Girona Optimization System) What is GOS? GOS is a declarative tool for modelling and solving any CSP to SAT, improving its expresiveness. GOS gives you an easy gateway for modelling with SAT . Model Model files is written in BUP language and defines: Necessary parameters (initially fixed sudoku values, board size,...). Variables used to model the problem. Constraints applied over those variables (no repeated numbers in each row, column and sub-square, initial values must be respected,...) Output format. Using BUP for modelling the Sudoku problem: viewpoint: var p[9][9][9]; param int iniSudoku[9][9]; constraints: forall(i in 0..8, j in 0..8){ EO(p[i][j][_]); // One value per cell AMO(p[i][_][j]); // Each value one time per row AMO(p[_][i][j]); // Each value one time per column }; //Each value one time per block forall(i in [0,3,6], j in [0,3,6], k in 0..8){ AMK([p[i+l][j+g][k] | l in 0..2, g in 0..2], 1); }; //Initialize input fixed sudoku values. forall(i in 0..8, j in 0..8){ if(iniSudoku[i][j] != 0){ p[i][j][iniSudoku[i][j]-1]; }; }; output: \"Sudoku solution: \\n\"; [ k+1 ++ \" \" ++ ((j+1) % 3 == 0 ? \" \" : \"\") ++ (j==8 ? (i+1) % 3 == 0 ? \"\\n\u2190\udbff\udc01 \udbff\udc00\u2192 \\n\": \"\\n\" : \"\") | i in 0..8, j in 0..8, k in 0..8 where p[i][j][k]]; The model has a parameter iniSudoku , that is the actual sudoku to solve, and an array of variables p , where p[i][j][k] is true when the cell with row i and column j has the value k . Parameters The parameters file, fills the requiered model parameters with concret values, according to the instance. The language used for the parameters file is JSON since supports all the data structures used by BUP. The following snippet is an example of a parameters file for the previous Sudoku model: { \"iniSudoku\" : [ [8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 6, 0, 0, 0, 0, 0], [0, 7, 0, 0, 9, 0, 2, 0, 0], [0, 5, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 4, 5, 7, 0, 0], [0, 0, 0, 1, 0, 0, 0, 3, 0], [0, 0, 1, 0, 0, 0, 0, 6, 8], [0, 0, 8, 5, 0, 0, 0, 1, 0], [0, 9, 0, 0, 0, 0, 4, 0, 0] ] } Output GOS compiler will process these data and will generate the propositional formula as a result of applying the defined constraints over the model variables. Once the formula is generated, the compiler can print the formula in a standard format, DIMACS , or apply the solver to get a solution . Basically, the process would be like doing a compilation of a high-level language (in our case, BUP), to assembler (where SAT is the assembler, the lowest-level language), using GOS compiler. Summary The GOS compiler allows to use the defined language, BUP , to solve CSP s. Given a BUP model and a JSON file with the data of a particular instance at hand, GOS compiler makes the translation to SAT and gives the option to print the resulting formula in a standard format, DIMACS, or to obtain a solution by using MiniSAT SAT-solver. There are two ways of using GOS compiler: - By building the project using CMake - By using the published online version (currently unavailable)","title":"GOS (Girona Optimization System)"},{"location":"gos_result/#gos-girona-optimization-system","text":"","title":"GOS (Girona Optimization System)"},{"location":"gos_result/#what-is-gos","text":"GOS is a declarative tool for modelling and solving any CSP to SAT, improving its expresiveness. GOS gives you an easy gateway for modelling with SAT .","title":"What is GOS?"},{"location":"gos_result/#model","text":"Model files is written in BUP language and defines: Necessary parameters (initially fixed sudoku values, board size,...). Variables used to model the problem. Constraints applied over those variables (no repeated numbers in each row, column and sub-square, initial values must be respected,...) Output format. Using BUP for modelling the Sudoku problem: viewpoint: var p[9][9][9]; param int iniSudoku[9][9]; constraints: forall(i in 0..8, j in 0..8){ EO(p[i][j][_]); // One value per cell AMO(p[i][_][j]); // Each value one time per row AMO(p[_][i][j]); // Each value one time per column }; //Each value one time per block forall(i in [0,3,6], j in [0,3,6], k in 0..8){ AMK([p[i+l][j+g][k] | l in 0..2, g in 0..2], 1); }; //Initialize input fixed sudoku values. forall(i in 0..8, j in 0..8){ if(iniSudoku[i][j] != 0){ p[i][j][iniSudoku[i][j]-1]; }; }; output: \"Sudoku solution: \\n\"; [ k+1 ++ \" \" ++ ((j+1) % 3 == 0 ? \" \" : \"\") ++ (j==8 ? (i+1) % 3 == 0 ? \"\\n\u2190\udbff\udc01 \udbff\udc00\u2192 \\n\": \"\\n\" : \"\") | i in 0..8, j in 0..8, k in 0..8 where p[i][j][k]]; The model has a parameter iniSudoku , that is the actual sudoku to solve, and an array of variables p , where p[i][j][k] is true when the cell with row i and column j has the value k .","title":"Model"},{"location":"gos_result/#parameters","text":"The parameters file, fills the requiered model parameters with concret values, according to the instance. The language used for the parameters file is JSON since supports all the data structures used by BUP. The following snippet is an example of a parameters file for the previous Sudoku model: { \"iniSudoku\" : [ [8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 6, 0, 0, 0, 0, 0], [0, 7, 0, 0, 9, 0, 2, 0, 0], [0, 5, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 4, 5, 7, 0, 0], [0, 0, 0, 1, 0, 0, 0, 3, 0], [0, 0, 1, 0, 0, 0, 0, 6, 8], [0, 0, 8, 5, 0, 0, 0, 1, 0], [0, 9, 0, 0, 0, 0, 4, 0, 0] ] }","title":"Parameters"},{"location":"gos_result/#output","text":"GOS compiler will process these data and will generate the propositional formula as a result of applying the defined constraints over the model variables. Once the formula is generated, the compiler can print the formula in a standard format, DIMACS , or apply the solver to get a solution . Basically, the process would be like doing a compilation of a high-level language (in our case, BUP), to assembler (where SAT is the assembler, the lowest-level language), using GOS compiler.","title":"Output"},{"location":"gos_result/#summary","text":"The GOS compiler allows to use the defined language, BUP , to solve CSP s. Given a BUP model and a JSON file with the data of a particular instance at hand, GOS compiler makes the translation to SAT and gives the option to print the resulting formula in a standard format, DIMACS, or to obtain a solution by using MiniSAT SAT-solver. There are two ways of using GOS compiler: - By building the project using CMake - By using the published online version (currently unavailable)","title":"Summary"},{"location":"identifiers/","text":"Identifiers The identifiers are words without whitespaces. They can only contain alphanumeric characters and underscores Identifiers cannot start with a number. <'a'..'z' | 'A'..'Z' | '_'> <'a'..'z' | 'A'..'Z' | '_' | '0'..'9'>*","title":"Identifiers"},{"location":"identifiers/#identifiers","text":"The identifiers are words without whitespaces. They can only contain alphanumeric characters and underscores Identifiers cannot start with a number. <'a'..'z' | 'A'..'Z' | '_'> <'a'..'z' | 'A'..'Z' | '_' | '0'..'9'>*","title":"Identifiers"},{"location":"introduction/","text":"Introduction C onstraint S atisfaction Problems ( CSP s) consists on finding values for a set of variables subject to a set of constraints. Examples of CSPs are well-known puzzles such as Sudoku or problems appearing in industry such as Scheduling or Timetabling. This kind of problems can be easily modelled with declarative programming languages. Declarative programming languages attempt to describe what the program must accomplish in terms of the problem domain , rather than describe how to accomplish it as a sequence of the programming language primitives. This is in contrast with imperative programming, which implements algorithms in explicit steps. A subset of declarative languages are modelling languages . This project will be focused on this subset and the main purpose will be get a new declarative programming language for modelling any CSP to Boolean Satisfiability SAT . SAT One of the most successful methodologies for solving CSP relies on the conversion into SAT problems, i.e., to build a Boolean formula that has a solution if and only if the original CSP has also a solution . The advantage is the wide availability of free and e\ufb00icient SAT-solvers . GOS & BUP The of the tool is GOS ( G irona O ptimization S ystem) and the language that uses is BUP . As a curiosity, the name choice lies in the fact that in Catalan , my mother tongue, GOS means dog and, also in Catalan, the onomatopoeia that describes the sound that dogs make (the language they speak) is BUP-BUP! (woof-woof!). Therefore, GOS (dog) is the name of the tool implemented and BUP (woof) is the language defined that is used by GOS. Apart from that, a real dog (GOS) can be considered a tracker, and that is also what the project is about: looking for a solution to CSPs.","title":"Introduction"},{"location":"introduction/#introduction","text":"C onstraint S atisfaction Problems ( CSP s) consists on finding values for a set of variables subject to a set of constraints. Examples of CSPs are well-known puzzles such as Sudoku or problems appearing in industry such as Scheduling or Timetabling. This kind of problems can be easily modelled with declarative programming languages. Declarative programming languages attempt to describe what the program must accomplish in terms of the problem domain , rather than describe how to accomplish it as a sequence of the programming language primitives. This is in contrast with imperative programming, which implements algorithms in explicit steps. A subset of declarative languages are modelling languages . This project will be focused on this subset and the main purpose will be get a new declarative programming language for modelling any CSP to Boolean Satisfiability SAT .","title":"Introduction"},{"location":"introduction/#sat","text":"One of the most successful methodologies for solving CSP relies on the conversion into SAT problems, i.e., to build a Boolean formula that has a solution if and only if the original CSP has also a solution . The advantage is the wide availability of free and e\ufb00icient SAT-solvers .","title":"SAT"},{"location":"introduction/#gos-bup","text":"The of the tool is GOS ( G irona O ptimization S ystem) and the language that uses is BUP . As a curiosity, the name choice lies in the fact that in Catalan , my mother tongue, GOS means dog and, also in Catalan, the onomatopoeia that describes the sound that dogs make (the language they speak) is BUP-BUP! (woof-woof!). Therefore, GOS (dog) is the name of the tool implemented and BUP (woof) is the language defined that is used by GOS. Apart from that, a real dog (GOS) can be considered a tracker, and that is also what the project is about: looking for a solution to CSPs.","title":"GOS &amp; BUP"},{"location":"lists/","text":"Lists Lists can be used to generate ranges to loop over arrays in forall structures. It is also allowed applying constraints over lists of variables, i.e., cardinalities, and constraints, or constraints, etc. A list could be: Range list <int_expr>..<int_expr> 1..5 generates the list [1,2,3,4,5] . 1..15/5 generates the list [1,2,3] . Comprehension list [<<expr | clause>> | <ident> in <list> (,<ident>} in <list>)* <where <bool_expr>>?] [i | i in 1..5] generates the list [1,2,3,4,5] . [i*j | i in 1..3, j in 1..3] generates the list [1,2,3,2,4,6,3,6,9] . [i*j | i in 1..3, j in 1..3 where i < j] generates the list [2,3,6] . Explicit list [<<expr> | <clause>> <, <<expr> | <clause>>*] [1,2,3,4,5] generates the list [1,2,3,4,5] . [1,2*4,7,14/2+1,76] generates the list *[1,8,7,8,76] All elements of a integer explicit list must be of the same type [a|b,a,c->d] generates the list [a V b, a, !c V d] . One-dimentional array <matrixRowAccess> See matrix row access section for more info. Given a one-dimensional array int arrayX[3] : - arrayX generates the list [arrayX[0], arrayX[1], arrayX[2]] Given a multi-dimensional array int arrayX[3][3][3] : - arrayX[0][_][0] generates the list [arrayX[0][0][0], arrayX[0][1][0], arrayX[0][2][0]] - arrayX[_][1][0] generates the list [arrayX[0][1][0], arrayX[1][1][0], arrayX[2][1][0]] List aggregation operators length The length operator returns the size of a list. length( <list> ) sum The sum operator returns the size of a list of integers. sum( <list_int> ) max The max operator returns the maximum number of a list of integers. max( <list_int> ) min The min operator returns the minimum number of a list of integers. min( <list_int> )","title":"Lists"},{"location":"lists/#lists","text":"Lists can be used to generate ranges to loop over arrays in forall structures. It is also allowed applying constraints over lists of variables, i.e., cardinalities, and constraints, or constraints, etc. A list could be:","title":"Lists"},{"location":"lists/#range-list","text":"<int_expr>..<int_expr> 1..5 generates the list [1,2,3,4,5] . 1..15/5 generates the list [1,2,3] .","title":"Range list"},{"location":"lists/#comprehension-list","text":"[<<expr | clause>> | <ident> in <list> (,<ident>} in <list>)* <where <bool_expr>>?] [i | i in 1..5] generates the list [1,2,3,4,5] . [i*j | i in 1..3, j in 1..3] generates the list [1,2,3,2,4,6,3,6,9] . [i*j | i in 1..3, j in 1..3 where i < j] generates the list [2,3,6] .","title":"Comprehension list"},{"location":"lists/#explicit-list","text":"[<<expr> | <clause>> <, <<expr> | <clause>>*] [1,2,3,4,5] generates the list [1,2,3,4,5] . [1,2*4,7,14/2+1,76] generates the list *[1,8,7,8,76] All elements of a integer explicit list must be of the same type [a|b,a,c->d] generates the list [a V b, a, !c V d] .","title":"Explicit list"},{"location":"lists/#one-dimentional-array","text":"<matrixRowAccess> See matrix row access section for more info. Given a one-dimensional array int arrayX[3] : - arrayX generates the list [arrayX[0], arrayX[1], arrayX[2]] Given a multi-dimensional array int arrayX[3][3][3] : - arrayX[0][_][0] generates the list [arrayX[0][0][0], arrayX[0][1][0], arrayX[0][2][0]] - arrayX[_][1][0] generates the list [arrayX[0][1][0], arrayX[1][1][0], arrayX[2][1][0]]","title":"One-dimentional array"},{"location":"lists/#list-aggregation-operators","text":"","title":"List aggregation operators"},{"location":"lists/#length","text":"The length operator returns the size of a list. length( <list> )","title":"length"},{"location":"lists/#sum","text":"The sum operator returns the size of a list of integers. sum( <list_int> )","title":"sum"},{"location":"lists/#max","text":"The max operator returns the maximum number of a list of integers. max( <list_int> )","title":"max"},{"location":"lists/#min","text":"The min operator returns the minimum number of a list of integers. min( <list_int> )","title":"min"},{"location":"quickstart/","text":"Nonogram Nonograms, also known as Picross or Griddlers, are image logic puzzles in which cells in a grid must be colored or blank according to the numbers on the side of the grid to reveal a hidden image. In this type of puzzle, numbers are a form of discrete tomography that measures the number of continuous lines of filled-in squares there are in any given row or column. For example, a track of \"4 8 3\" would mean that there are sets of four, eight, and three filled squares, in that order, with at least one blank square between successive groups. We can encode nonograms with BUP using the following parameters and variables defined in the viewpoint block: viewpoint: param int rowSize; param int colSize; param int maxNonos; param int rowNonos[rowSize][maxNonos]; param int colNonos[colSize][maxNonos]; var x[rowSize][colSize]; var hasStartedRow[rowSize][maxNonos][colSize]; var hasStartedCol[colSize][maxNonos][rowSize]; rowSize is the grid row size. colSize is the grid column size. maxNonos is the maximum number of blocks that a column or a row could have rowNonos indicates the number of blocks and its sizes in each row. colNonos indicates the number of blocks and its sizes in each column. x is the result board: x[i][j] will be true if and only if row i , column j is coloured and false otherwise. hasStartedRow[i][b][j] will be true if and only if block b of row i has already started in the column j . hasStartedCol[j][b][i] will be true if block b of column j has already started in the row i . The constraints are the same applied over columns and over rows. The following constrains are those applied over rows: If a block of a row has started at column i , it also must have started in column i+1 . //Order encoding forall(i in 0..rowSize-1, b in 0..maxNonos-1){ if(rowNonos[i][b] != 0){ forall(j in 0..colSize-2){ hasStartedRow[i][b][j] -> hasStartedRow[i][b][j+1]; }; } else{ &&( [!hasStartedRow[i][b][j] | j in 0..colSize-1] ); }; }; A block mush have started soon enough to fit in the row. forall(i in 0..rowSize-1, b in 0..maxNonos-1){ if(rowNonos[i][b] != 0){ hasStartedRow[i][b][colSize-rowNonos[i][b]]; }; }; x[i][j] must be true if it is colored. //Channelling between hasStarted and x forall(i in 0..rowSize-1, b in 0..maxNonos-1){ if(rowNonos[i][b] != 0){ forall(j in 0..colSize-1){ if(j >= rowNonos[i][b]){ x[i][j] <- hasStartedRow[i][b][j] & !hasStartedRow[i][b][j-rowNonos[i][b]]; } else { x[i][j] <- hasStartedRow[i][b][j]; }; }; }; }; The number of cells true in the row i must be the sum of the length of the blocks in row i . forall(i in 0..rowSize-1){ EK(x[i], sum(rowNonos[i])); }; Block b must start before block b+1 forall(i in 0..rowSize-1, b in 0..maxNonos-2){ if(rowNonos[i][b+1] != 0){ forall(j in 0..colSize-1){ if(j-rowNonos[i][b]-1 >= 0){ hasStartedRow[i][b+1][j] -> hasStartedRow[i][b][j-rowNonos[i][b]-1]; } else { !hasStartedRow[i][b+1][j]; }; }; }; }; Sudoku Sudoku is a popular Japanese puzzle that is based on the logical placement of numbers. The goal of Sudoku is to fill in a 9\u00d79 grid with digits so that each column, row, and 3\u00d73 section contain the numbers between 1 to 9. At the beginning of the game, the 9\u00d79 grid will have some of the squares filled in. Your job is to use logic to fill in the missing digits and complete the grid. The mathematical model of the sudoku is the following: Sets G = Set of already placed numbers Variables Constraints Only one k in each column Only one k in each row Only one k in each sub-matrix Every poistion in the matrix must be filled once Given elements G in matrix are set \u201con\u201d A 9x9 sudoku can be modelled using BUP as: viewpoint: var p[9][9][9]; param int iniSudoku[9][9]; constraints: forall(i in 0..8, j in 0..8){ EO(p[i][j][_]); // One value per cell AMO(p[i][_][j]); // Each value one time per row AMO(p[_][i][j]); // Each value one time per column }; //Each value one time per block forall(i in [0,3,6], j in [0,3,6], k in 0..8){ AMK([p[i+l][j+g][k] | l in 0..2, g in 0..2], 1); }; //Initialize input fixed sudoku values. forall(i in 0..8, j in 0..8){ if(iniSudoku[i][j] != 0){ p[i][j][iniSudoku[i][j]-1]; }; }; output: \"Sudoku solution: \\n\"; [ k+1 ++ \" \" ++ ((j+1) % 3 == 0 ? \" \" : \"\") ++ (j==8 ? (i+1) % 3 == 0 ? \"\\n\\n\": \"\\n\" : \"\") | i in 0..8, j in 0..8, k in 0..8 where p[i][j][k]]; And the following input parameters: { \"iniSudoku\" : [ [8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 6, 0, 0, 0, 0, 0], [0, 7, 0, 0, 9, 0, 2, 0, 0], [0, 5, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 4, 5, 7, 0, 0], [0, 0, 0, 1, 0, 0, 0, 3, 0], [0, 0, 1, 0, 0, 0, 0, 6, 8], [0, 0, 8, 5, 0, 0, 0, 1, 0], [0, 9, 0, 0, 0, 0, 4, 0, 0] ] } The solution obtained is: c restarts 3 c decisions 490 c propagations 108196 c conflics 291 c stats 0;0;0.043765;-1;4536;11361;3;-1;-1;490;108196;291;-1;-1; v s SATISFIABLE Soluci\u00f3 sudoku: 8 1 2 7 5 3 6 4 9 9 4 3 6 8 2 1 7 5 6 7 5 4 9 1 2 8 3 1 5 4 2 3 7 8 9 6 3 6 9 8 4 5 7 2 1 2 8 7 1 6 9 5 3 4 5 2 1 9 7 4 3 6 8 4 3 8 5 2 6 9 1 7 7 9 6 3 1 8 4 5 2","title":"Quickstart"},{"location":"quickstart/#nonogram","text":"Nonograms, also known as Picross or Griddlers, are image logic puzzles in which cells in a grid must be colored or blank according to the numbers on the side of the grid to reveal a hidden image. In this type of puzzle, numbers are a form of discrete tomography that measures the number of continuous lines of filled-in squares there are in any given row or column. For example, a track of \"4 8 3\" would mean that there are sets of four, eight, and three filled squares, in that order, with at least one blank square between successive groups. We can encode nonograms with BUP using the following parameters and variables defined in the viewpoint block: viewpoint: param int rowSize; param int colSize; param int maxNonos; param int rowNonos[rowSize][maxNonos]; param int colNonos[colSize][maxNonos]; var x[rowSize][colSize]; var hasStartedRow[rowSize][maxNonos][colSize]; var hasStartedCol[colSize][maxNonos][rowSize]; rowSize is the grid row size. colSize is the grid column size. maxNonos is the maximum number of blocks that a column or a row could have rowNonos indicates the number of blocks and its sizes in each row. colNonos indicates the number of blocks and its sizes in each column. x is the result board: x[i][j] will be true if and only if row i , column j is coloured and false otherwise. hasStartedRow[i][b][j] will be true if and only if block b of row i has already started in the column j . hasStartedCol[j][b][i] will be true if block b of column j has already started in the row i . The constraints are the same applied over columns and over rows. The following constrains are those applied over rows: If a block of a row has started at column i , it also must have started in column i+1 . //Order encoding forall(i in 0..rowSize-1, b in 0..maxNonos-1){ if(rowNonos[i][b] != 0){ forall(j in 0..colSize-2){ hasStartedRow[i][b][j] -> hasStartedRow[i][b][j+1]; }; } else{ &&( [!hasStartedRow[i][b][j] | j in 0..colSize-1] ); }; }; A block mush have started soon enough to fit in the row. forall(i in 0..rowSize-1, b in 0..maxNonos-1){ if(rowNonos[i][b] != 0){ hasStartedRow[i][b][colSize-rowNonos[i][b]]; }; }; x[i][j] must be true if it is colored. //Channelling between hasStarted and x forall(i in 0..rowSize-1, b in 0..maxNonos-1){ if(rowNonos[i][b] != 0){ forall(j in 0..colSize-1){ if(j >= rowNonos[i][b]){ x[i][j] <- hasStartedRow[i][b][j] & !hasStartedRow[i][b][j-rowNonos[i][b]]; } else { x[i][j] <- hasStartedRow[i][b][j]; }; }; }; }; The number of cells true in the row i must be the sum of the length of the blocks in row i . forall(i in 0..rowSize-1){ EK(x[i], sum(rowNonos[i])); }; Block b must start before block b+1 forall(i in 0..rowSize-1, b in 0..maxNonos-2){ if(rowNonos[i][b+1] != 0){ forall(j in 0..colSize-1){ if(j-rowNonos[i][b]-1 >= 0){ hasStartedRow[i][b+1][j] -> hasStartedRow[i][b][j-rowNonos[i][b]-1]; } else { !hasStartedRow[i][b+1][j]; }; }; }; };","title":"Nonogram"},{"location":"quickstart/#sudoku","text":"Sudoku is a popular Japanese puzzle that is based on the logical placement of numbers. The goal of Sudoku is to fill in a 9\u00d79 grid with digits so that each column, row, and 3\u00d73 section contain the numbers between 1 to 9. At the beginning of the game, the 9\u00d79 grid will have some of the squares filled in. Your job is to use logic to fill in the missing digits and complete the grid. The mathematical model of the sudoku is the following:","title":"Sudoku"},{"location":"quickstart/#sets","text":"G = Set of already placed numbers","title":"Sets"},{"location":"quickstart/#variables","text":"","title":"Variables"},{"location":"quickstart/#constraints","text":"Only one k in each column Only one k in each row Only one k in each sub-matrix Every poistion in the matrix must be filled once Given elements G in matrix are set \u201con\u201d A 9x9 sudoku can be modelled using BUP as: viewpoint: var p[9][9][9]; param int iniSudoku[9][9]; constraints: forall(i in 0..8, j in 0..8){ EO(p[i][j][_]); // One value per cell AMO(p[i][_][j]); // Each value one time per row AMO(p[_][i][j]); // Each value one time per column }; //Each value one time per block forall(i in [0,3,6], j in [0,3,6], k in 0..8){ AMK([p[i+l][j+g][k] | l in 0..2, g in 0..2], 1); }; //Initialize input fixed sudoku values. forall(i in 0..8, j in 0..8){ if(iniSudoku[i][j] != 0){ p[i][j][iniSudoku[i][j]-1]; }; }; output: \"Sudoku solution: \\n\"; [ k+1 ++ \" \" ++ ((j+1) % 3 == 0 ? \" \" : \"\") ++ (j==8 ? (i+1) % 3 == 0 ? \"\\n\\n\": \"\\n\" : \"\") | i in 0..8, j in 0..8, k in 0..8 where p[i][j][k]]; And the following input parameters: { \"iniSudoku\" : [ [8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 6, 0, 0, 0, 0, 0], [0, 7, 0, 0, 9, 0, 2, 0, 0], [0, 5, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 4, 5, 7, 0, 0], [0, 0, 0, 1, 0, 0, 0, 3, 0], [0, 0, 1, 0, 0, 0, 0, 6, 8], [0, 0, 8, 5, 0, 0, 0, 1, 0], [0, 9, 0, 0, 0, 0, 4, 0, 0] ] } The solution obtained is: c restarts 3 c decisions 490 c propagations 108196 c conflics 291 c stats 0;0;0.043765;-1;4536;11361;3;-1;-1;490;108196;291;-1;-1; v s SATISFIABLE Soluci\u00f3 sudoku: 8 1 2 7 5 3 6 4 9 9 4 3 6 8 2 1 7 5 6 7 5 4 9 1 2 8 3 1 5 4 2 3 7 8 9 6 3 6 9 8 4 5 7 2 1 2 8 7 1 6 9 5 3 4 5 2 1 9 7 4 3 6 8 4 3 8 5 2 6 9 1 7 7 9 6 3 1 8 4 5 2","title":"Constraints"},{"location":"result/","text":"","title":"Result"},{"location":"strings/","text":"Strings BUP allows string only in the output block. A string could be: An explicit string by adding quotes at the beginning and at the end of the text: A string concat using ++ operator: <string> <++ <string>>* A string between parenthesis : ( <string> ) A ternary operation having a string expression to the both sides: <boolExpression> : ? <string1> : <string2> A variable or param access automatically casted to string. > Strings are only allowed in output block, where variables are treated as bool basic type Variables are automatically casted to bool basic type to do operations between expressions in the output-block. - An expression result, automatically casted to string. - A list automatically casted to string. Lists are casted to string using the format \"[<expr> , <expr*>]\"","title":"Strings"},{"location":"strings/#strings","text":"BUP allows string only in the output block. A string could be: An explicit string by adding quotes at the beginning and at the end of the text: A string concat using ++ operator: <string> <++ <string>>* A string between parenthesis : ( <string> ) A ternary operation having a string expression to the both sides: <boolExpression> : ? <string1> : <string2> A variable or param access automatically casted to string. > Strings are only allowed in output block, where variables are treated as bool basic type Variables are automatically casted to bool basic type to do operations between expressions in the output-block. - An expression result, automatically casted to string. - A list automatically casted to string. Lists are casted to string using the format \"[<expr> , <expr*>]\"","title":"Strings"}]}